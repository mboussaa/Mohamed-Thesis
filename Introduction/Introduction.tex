\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
%------------------------------%
%------------------------------%
\markboth{Introduction}{Introduction}
\section*{Context}
Modern software systems rely nowadays on a highly heterogeneous and dynamic interconnection of platforms and devices that provide a wide diversity of capabilities and services. These heterogeneous services may run in different environments ranging from cloud servers with virtually unlimited resources down to resource-constraint devices with only a few KB of RAM. Effectively developing software artifacts for multiple target platforms and hardware technologies is then becoming increasingly important. As a consequence, we observe in the last years[REF], that high-level abstract development received more and more attraction to tame with the runtime heterogeneity of platforms and technological stacks that exists in several domains such as mobile or Internet of Things.
Therefore, software developers tend to increasingly use generative programming and model-based techniques in order to reduce the effort of software development and maintenance by developing at a higher-level of abstraction through the use of domain-specific languages for example. 
Consequently, the new advances in hardware and platform specifications have paved the way for the creation of multiple code generators and compilers that serve as a basis to target different ranges of platforms. 
On the one hand, code generators are needed to translate high-level system specifications (e.g., textual or graphical modeling language) into multi-target executable code (e.g., general-purpose languages such as Java, C++, etc).
On the other hand, a set of platform-specific compilers are also needed in turn to transform general-purpose languages into machine code (i.e., binaries). 


However, code generators as well as compilers are known to be difficult to understand since they involve a set of complex and heterogeneous technologies and configurations which make the activities of design, implementation, and testing very hard and time-consuming [REF]. Thus, their output must be checked with almost the same, expensive effort as is needed for manually written code. 
Thus, testing code generators and compilers becomes crucial and necessary to guarantee that no errors are incorporated by inappropriate modelling or by the code generator it self. 
Faulty code generators or compilers can generate defective software artifacts which range from uncompilable or semantically dysfunctional code that causes serious damage to the target platform; to non-functional bugs which lead to poor-quality code that can affect system reliability and performance (e.g., high resource usage, high execution time, etc.). 
Numerous approaches have been proposed [ref] to verify the functional outcome of generated code. However, there is a lack of solutions that pay attention to evaluate the non-functional properties of produced code.

In this thesis, we seek to test the non-functional properties, i.e., resource usage properties, of generated code by either code generators or compilers. On the one hand, since many different target software platforms can be targeted by the code generator, we would help code generator creators to monitor the execution of generated code for different targets and have a deep understanding of its non-functional behavior in terms of resource usage. Thus, we can detect bugs and inconsistencies caused by some faulty code generators. On the other hand, compilers may have a huge number of optimizations and code transformation rules that can be applied during the code generation process. As a consequence, we would help compiler users to select the best optimizations that satisfy specific resource usage requirements for a broad range of programs and hardware architectures.

\textit{This thesis addresses the problem of non-functional testing of code generators and compilers}. In particular, it aims at offering effective support for collecting
data about resource consumption (e.g., CPU, memory), as well
as efficient mechanisms to help software developers to choose the best configuration that satisfy specific non-functional requirements and lead to performance improvement.

\iffalse
reserve resources for specific applications. Unfortunately,
the mechanisms needed to support resource-aware programming highly depend on the
target technology. For instance, reserving memory for a native Unix process is different
from reserving memory for an OSGi bundle (i.e., the former problem involves creating a
virtual address space [Sta14] while the latter demands the usage of a memory allocator
and a garbage collector [OSG14, AAB+00, RHM12, GTL+10]). As a consequence, the
solutions we discuss in our research are mostly useful to support resource-awareness in
the context of MRTEs. In particular, we focus on this kind of execution environment
when we present the contributions of this thesis.

 
 




However, at present, 

Producing correct and effective code generators is complex and error-prone. software designers provide generally high-level test suites to verify the functional outcome of generated code

However, creating effective code generator/compiler is complex because the programmer must have a deep understanding of all the different target hardware components and programming models, as well as understand how to use them together. Even with this understanding, the best way of dividing work
across the hardware is often affected by application variables such as dataset size, making it nontrivial to realize maximal performance improvement.

For instance, code generators, as well as compilers, generally come with numerous features and configurations. Software developers can then design and configure them in order to produce code for a specific target platform in a an effective way. 


 Although software designers provide generally
high-level test suites to verify the functional outcome of generated
code, it remains challenging and tedious to verify the behavior
of produced code in terms of non-functional properties









//The current innovations in science and industry with the rapidly evolving hardware, 
Due to rapidly evolving hardware and system specifications, 

Due to new advances in hardware and system specification, creating an effective code generators (including compilers) is not simple and it is becoming more and more challenging. must take into consideration the current innovations in science and industry caused by rapidly evolving hardware


The creation of effective code generators (including compilers) implies 



However 

//This has paved the way for software developers to tend to use generative programming techniques such as model-based developement. 


//which provides an elegant engineering solution 
advances in hardware and network technologies have paved the way for
//received more and more attraction
the intensive use of

//ranging from cloud servers with virtually unlimited resources down to micro-controllers with only a few KB of RAM.

//Thus, developing manually software programs for different platforms is tedious and //time-consuming 


model-based software development 

toolboxes 

 

Advances in hardware and network technologies have
paved the way for the development of increasingly pervasive
software-based systems of systems that collaborate
to provide essential services to society. Software in these
systems is often required to (1) operate in distributed and
embedded computing environments consisting of diverse
devices (personal computers, specialized sensors and actuators),
(2) communicate using a variety of interaction
paradigms (e.g., SOAP messaging, media streaming), (3)
dynamically adapt to changes in operating environments,
and (4) behave in a dependable manner [26, 62]. Despite
significant advances in programming languages and
supporting integrated development environments (IDEs),
developing these complex software systems using current
code-centric technologies requires herculean effort.


These
heterogeneous architectures continue to provide increases in
achievable performance, but unfortunately programming these
devices to reach maximum performance levels is not straightforward.
Each heterogeneous element has its own performance
characteristics and pitfalls, and usually comes with its own
programming model. Therefore when targeting such architectures,
the programmer must have a deep understanding
of all the different hardware components and programming
models, as well as understand how to use them together.
Even with this understanding, the best way of dividing work
across the hardware is often affected by application variables
such as dataset size, making it nontrivial to realize maximal
performance improvement.
The difficulty of programming heterogeneous parallel architectures
results in a severe loss in programmer productivity.
In addition to the significantly increased effort needed to
achieve correctness and performance during initial development,
exposing all the low level details of each compute
device is detrimental to the maintainability, future scalability,
and portability of the application. In order to alleviate these
problems, it is essential to develop high level abstractions that
allow programmers to develop high performance programs
with high productivity.
Ideally a programming language should provide generality,
high productivity, and produce high-performance binaries that
take advantage of all the hardware resources available in a
given platform. Unfortunately, no such language currently exists.
A more tenable goal is to create a language that trades-off
one desirable aspect to achieve the others. A compromise that
has the potential to attain both productivity and performance
is to use languages targeted to a specific application domain,
so called domain-specific languages (DSLs) [4]. DSLs can
provide a higher level of abstraction than general-purpose
languages and can enable mappings between domain abstractions
and efficient parallel implementations. In addition DSLs
enable domain-specific static and dynamic optimizations that
would not be possible with a general-purpose compiler and
runtime system.


Code generators are increasingly used in an industrial context to
translate graphical models into executable code. Since the code is
often deployed in safety-related environments, the quality of the
code generators is of paramount importance

\fi


\section*{Challenges}
In existing solutions that aim to test code generators and compilers, we find two important challenges. Addressing these challenges, which are described below, is the objective of the present work.
\begin{itemize}
\item
\textbf{Monitoring code generators/compilers behavior:} For testing the non-functional properties of code generators and compilers, developers generally need to deploy and execute generated software artifacts on different execution platforms. Then, they have to collect and compare information about the performance and efficiency of the generated code. Afterwards, they report issues related to the code generation process such as incorrect typing, memory management leaks, etc. Currently, there is a lack of automatic solutions to check the performance issues such as the inefficiency (high memory/CPU consumption) of the generated code. In fact, developers often use manually several platform-specific profilers, debuggers, and monitoring tools [REF] in order to find some inconsistencies or bugs during code execution. Ensuring the quality of generated code in this case can refer to several non-functional properties such as code size, resource or energy consumption, execution time, among others [REF]. Due to the heterogeneity of execution platforms and hardwares, collecting information about the non-functional properties of generated code becomes very hard and time-consuming task since developers have to analyze and verify the generated code for different target platforms using platform-specific tools.
\item
\textbf{Tuning code generators/compilers:} The current innovations in science and industry demand ever-increasing computing resources while placing strict requirements on many non-functional properties such as system performance, power consumption, size, response, reliability, etc. In order to deliver satisfactory levels of performance on different processor architectures, compiler creators often provide a broad collection of optimizations that can be applied by compiler users in order to improve the quality of generated code. However, to explore the large optimization space, users have to evaluate the effect of optimizations according to a specific performance objective/trade-off. Thus, constructing a good set of optimization levels for a specific system architecture/target application becomes challenging and time-consuming problem. Due to the complex interactions and the unknown effect of optimizations, users find difficulties to choose the adequate compiler configuration that satisfy a specific non-functional requirement.





%while satisfying all the non-functional requirements for a broad range of programs and architectures
 


\end{itemize}
The challenges this research tackle can be summarized in the following research
questions. These questions arise from the analysis of the drawbacks in the previous paragraphs.

\textit{RQ1.} How can we help users to choose the adequate compiler/code generator configuration that satisfy user non-functional requirements?

\textit{RQ2.} How can we provide efficient support for resource consumption monitoring and management?

\textit{RQ3.} How can we automatically detect inconsistencies and non-functional errors within code generators?



\section*{Contributions}
This thesis establishes two core contributions in the field of non-functional testing of code generators and compilers. 
These contributions are briefly described in the rest of this section.

\textbf{Contribution: automatic compiler auto-tuning according to the non-functional requirements.}
We provide facilities to compiler users to auto-tune compilers according to their non-functional requirements and construct optimizations that
yield to better performance results than standard optimization levels. We also demonstrate that our approach can be used to automatically construct optimization levels that represent optimal trade-offs between multiple non-functional properties such as execution time and resource usage requirements.

\textbf{Contribution: automatic detection of inconsistencies within code generators families.}
In this contribution, we propose a new approach for testing and
monitoring code generators families. This approach try to find automatically real issues in existing code generators. In particular, we show that we could find two kinds of errors: the lack of use of a specific function and an abstract type that exist in the standard library of the target language which can reduce the memory usage/execution time of the resulting program.

\textbf{Contribution: a microservice-based infrastructure for runtime deployement and monitoring of generated code.}
We propose a micro-service infrastructure to ensure the deployment and monitoring of different variants of generated code. This isolated and sand-boxing environment is based on system containers, as execution platforms, to provide a fine-grained understanding and analysis of resource usage in terms of CPU and memory. This contribution answers mainly \textit{RQ2} but the same infrastructure is used across all experiments in \textit{RQ1} and \textit{RQ3}.

\section*{Overview of this thesis}

\section*{Publications}

\begin{itemize}

	\item Mohamed Boussaa, Olivier Barais, Benoit Baudry, Gerson Sunyé:
	\textbf{NOTICE: A Framework for Non-functional Testing of Compilers}. In 
	\textit{2016 IEEE International Conference on Software Quality, Reliability \& Security (QRS 2016)}, Vienna, Austria, August 2015.
	
	\item Mohamed Boussaa, Olivier Barais, Gerson Sunyé, Benoit Baudry:
	\textbf{A Novelty Search-based Test Data Generator for Object-oriented Programs}. In \textit{Genetic and Evolutionary Computation Conference Companion (GECCO 2015)}, Madrid, Spain, July 2015.
	
	\item Mohamed Boussaa, Olivier Barais, Gerson Sunyé, Benoit Baudry:
	\textbf{A Novelty Search Approach for Automatic Test Data Generation}. In
	\textit{8th International Workshop on Search-Based Software Testing (SBST@ICSE 2015)}, Florence, Italy, May 2015.

	
	
\end{itemize}

\subsection*{Under Review}
	Mohamed Boussaa, Olivier Barais, Gerson Sunyé, Benoit Baudry:
	\textbf{Automatic Non-functional Testing of Code Generators Families}. In
	\textit{10th IEEE International Conference on Software Testing, Verification and Validation (ICST 2017)}.
