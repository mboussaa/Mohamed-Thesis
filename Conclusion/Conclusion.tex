In this chapter, we first summarize all the contributions of this thesis, recalling the challenges and how we addressed each of them. Next and finally, we discuss some perspectives for future work.

\section{Conclusion}
Today's modern software development requires more automatic and flexible approaches to face the continuous innovation in industry production.
As a consequence, generative programming (GP) techniques are increasingly applied to automatically generate and reuse software artifacts.
GP is a software engineering paradigm that focuses on the automatic software synthesis to improve programmer productivity. It allows software programmers to write code at a higher abstraction level 
 
%in order to provide a new integrated software engineering approach which enables the advanced exploitation of the different dimensions of software diversity. 



\section{Perspectives}
As a future work, we plan to explore more trade-offs among resource usage metrics \eg, the correlation between CPU consumption and platform architectures. 
We also intend to provide more facilities to NOTICE users in order to test optimizations performed by modern compilers such as Clang, LLVM, etc.
Finally, NOTICE can be easily adapted and integrated to new case studies. As an example, we would inspect the behavior of model-based code generators since different optimizations can be performed to generate code from models~\cite{stuermer2007systematic}. Thus, we aim to use the same approach to find non-functional issues during the code generation process.
%As an alternative, it would be great to test model-based code generators. In the same fashion as Csmith, code generators apply to same rules to generate new software programs. Thus, we can use NOTICE to define general-purpose optimizations from a set of generated code artifacts. 

//Auto-tuning JIT, JVM en utilisant docker